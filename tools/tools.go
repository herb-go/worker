package tools

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
)

type Worker struct {
	Name string
	Type string
}
type Package struct {
	Name       string
	ID         string
	ImportPath string
	Path       string
	Workers    []string
}

func (p *Package) AddWorker(name string) {
	p.Workers = append(p.Workers, name)
}
func (p *Package) IsEmpty() bool {
	return len(p.Workers) == 0
}
func NewPackage() *Package {
	return &Package{
		Workers: []string{},
	}
}

type Context struct {
	Ignored       map[string]bool
	Writer        io.Writer
	Overseers     map[string]string
	OverseersPath string
	WorkerSuff    string
	Root          string
	Checked       map[string]bool
	Result        []*Package
	Filename      string
	FileMode      os.FileMode
}

func (c *Context) Printf(format string, v ...interface{}) {
	if c.Writer != nil {
		fmt.Fprintf(c.Writer, format, v...)
	}
}

func (c *Context) MustCheckFolder(path string) {
	fset := token.NewFileSet()
	f, err := parser.ParseDir(fset, path, nil, 0)
	if err != nil {
		panic(err)
	}
	var conf = types.Config{Importer: importer.ForCompiler(fset, "source", nil)}
	for _, ppkg := range f {
		files := make([]*ast.File, 0, len(ppkg.Files))
		for _, v := range ppkg.Files {
			files = append(files, v)
		}
		pkg, err := conf.Check(path, fset, files, nil)
		if err != nil {
			panic(err)
		}
		for _, v := range pkg.Imports() {
			c.CheckPackage(v)
		}
	}
}
func (c *Context) CheckPackage(pkg *types.Package) {
	if c.Root[len(c.Root)-1:] != "/" {
		c.Root = c.Root + "/"
	}
	path := pkg.Path()
	if c.Checked[path] {
		return
	}
	c.Checked[path] = true
	p, err := build.Default.Import(path, c.Root, build.FindOnly)
	if err != nil {
		panic(err)
	}
	if !strings.HasPrefix(p.Dir+"/", c.Root) {
		return
	}
	tp := NewPackage()
	tp.Name = pkg.Name()
	tp.ImportPath = path
	tp.Path = p.Dir
	tp.ID = strings.TrimPrefix(p.Dir, c.Root)
	if path != c.OverseersPath {
		for _, v := range pkg.Scope().Names() {
			obj := pkg.Scope().Lookup(v)
			if !obj.Exported() {
				continue
			}
			t := obj.Type().String()
			if c.Overseers[t] == "" {
				continue
			}
			tp.AddWorker(v)
			c.Printf("Worker \"%s\" (%s) in %s found.\n", v, t, tp.ID)
		}
	}
	if !tp.IsEmpty() {
		c.Result = append(c.Result, tp)
	}
	for _, v := range pkg.Imports() {
		c.CheckPackage(v)
	}
}
func (c *Context) MustLoadOverseers(path string) {
	p, err := build.Default.Import(path, c.Root, build.FindOnly)
	if err != nil {
		panic(err)
	}
	c.OverseersPath = p.ImportPath
	// c.Checked[p.ImportPath] = true
	fset := token.NewFileSet()
	f, err := parser.ParseDir(fset, p.Dir, nil, 0)
	if err != nil {
		panic(err)
	}
	var conf = types.Config{Importer: importer.ForCompiler(fset, "source", nil)}
	for _, ppkg := range f {
		files := make([]*ast.File, 0, len(ppkg.Files))
		for _, v := range ppkg.Files {
			files = append(files, v)
		}
		pkg, err := conf.Check(p.Dir, fset, files, nil)
		if err != nil {
			panic(err)
		}
		for _, v := range pkg.Scope().Names() {
			if strings.HasSuffix(v, c.WorkerSuff) && v != c.WorkerSuff {
				obj := pkg.Scope().Lookup(v)
				if !obj.Exported() {
					continue
				}
				t := obj.Type().String()
				if !c.Ignored[t] {
					c.Printf("Overseer \"%s\" (%s) found.\n", v, t)
					c.Overseers[t] = v
				}
			}
		}
	}
}

func (c *Context) MustRender() map[string][]byte {
	result := map[string][]byte{}
	for _, v := range c.Result {
		buf := bytes.NewBuffer(nil)
		err := Template.Execute(buf, v)
		if err != nil {
			panic(err)
		}
		result[filepath.Join(v.Path, c.Filename)] = buf.Bytes()
	}
	return result
}

func (c *Context) MustRenderAndWrite() {
	result := c.MustRender()
	for k, v := range result {
		err := ioutil.WriteFile(k, v, c.FileMode)
		if err != nil {
			panic(err)
		}
		c.Printf("File %s generated. \n", k)
	}
}
func NewContext() *Context {
	return &Context{
		Ignored:    map[string]bool{},
		Overseers:  map[string]string{},
		WorkerSuff: "Worker",
		Checked:    map[string]bool{},
		Result:     []*Package{},
		Filename:   "workers.autogenerated.go",
		FileMode:   0660,
	}
}
